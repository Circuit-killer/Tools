//======================================================
// ALIGN v 1.0.1
//
// Eagle v5.7 or later is required. Only the board editor is supported.
//
// Aligns board components in group or listed at the command line
// The direction of alignment is autodetected. The components are aligned
// after the origins of the top or leftmost component
//
// This software is released under the BSD 4-clause license:
//
// Copyright (c) 2010, Damhave Systems
// All rights reserved.

// Modified 2010-05-21 LJW - Correct group coordinate determination & quote output script name on exit

// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

//	*	Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
//	*	Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer
// 		in the documentation and/or other materials provided with the distribution.
//	*	Neither the name of the Damhave Systems nor the names of its contributors may be used to endorse or promote products derived from
//	    this software without specific prior written permission.
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
// BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
// GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
// STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
// OF SUCH DAMAGE.
//======================================================
#usage	"<B>Aligns board components in group or listed at the command line</B>"
"<P>"
	"Usage:<br>"
	"run align<br>"
	"run align [-flag{flag}] {component}<br><br>"
	"Flags:<br>"
	"d: distribute equally<br>"
	"e: use regular expressions (regex) instead of wildcards<br>"	
	"g: align to grid<br>"	
	"s: snap to grid<br>"
	"<P>"
	"Example: run align -gd LED*"
	"<P>"
	"Copyright (c) 2010 Damhave Systems"
	"<P>"
	"<Author>Danny Damhave<br>Damhave Systems<br>www.damhave.com</Author><br><br>"
	"This ulp is released under the BSD 4-clause license. See source code for details!"
	

enum {false, true};
enum {HORIZONTAL, VERTICAL};
enum {GROUP, LIST};
string outputFileName = "aligntempfile.scr";
int alignment, xAligned, yAligned, xMin = INT_MAX, xMax = INT_MIN, yMax = INT_MIN, yMin = INT_MAX, noElements = 0, mode = GROUP, firstInList = 1,
	alignToGridFlag = 0, regexFlag = 0, snapFlag = 0, distributeFlag = 0;
real distance, xAvg = 0.0, yAvg = 0.0;

int isMatch(string s, string test, int useRegex)
{	
	string regex = !useRegex ?  "^" : test;
	if (!useRegex)
	{
		for(int i = 0; test[i];)
		{
			switch(test[i])
			{
				case '[': regex += strsub(test, i, strchr(test, ']', i) - i + 1), i += strchr(test, ']', i) - i + 1; break;
				case '?': regex += ".", i++; break;
				case '*': regex += ".*", i++; break;
				case '^': case '$': case '.': case '{': case '}': case '(': case ')':  case '|': case '\\':
				regex += "\\" + test[i], i++; break;
				default: regex += test[i], i++;
			}
		}
		regex +='$';
	}
	return strxstr(s, regex, 0) == 0;
}

int inList(string name)
{
	for(int i = firstInList; i < argc && argv[i] != ""; i++)
	if (regexFlag)
	{
		if (isMatch(name, argv[i], regexFlag)) return true;
	}
	else
	{
		if (isMatch(name, strupr(argv[i]), regexFlag)) return true;		
	}
	return false;
}

int snapToGrid(UL_BOARD brd, int coordinate)
{
	real gSize;
	if (brd.grid.unitdist == GRID_UNIT_MIC) gSize = brd.grid.distance * 10;
	else if  (brd.grid.unitdist == GRID_UNIT_MM) gSize = brd.grid.distance * 10000;
	else if  (brd.grid.unitdist == GRID_UNIT_MIL) gSize = brd.grid.distance * 254;
	else if  (brd.grid.unitdist == GRID_UNIT_INCH) gSize = brd.grid.distance * 254000;
	return (round (coordinate / gSize) * gSize);	
}

//		***** The ulp begins here *****
if (!board && !dlgMessageBox("Can only be used in board editor.\n")) exit(1);
if (EAGLE_VERSION < 5 || (EAGLE_VERSION == 5 && EAGLE_RELEASE < 7) && !dlgMessageBox("Requires Eagle v5.7 or later.\n")) exit(1);

string dummy[];
if (!fileglob(dummy, path_ulp[0]  + "/"+ "accepted1.txt"))
{
	if (!dlgMessageBox("Please consider to outsource your hardware design reviews and designs to\n\n               Damhave Systems\n\n              www.damhave.com\n\nThis software is released under the 4-clause BSD license. See the source code for details.\n", "I Accept", "Cancel"))
	{
		output(path_ulp[0] + "/"+ "accepted1.txt", "wt") { printf("Accepted\n"); }	
	}
	else exit(0);
}

while (argc>firstInList)
{
	string flags = argv[firstInList];
	if (flags[0] == '-')
	{
		if (strlen(flags) == 1) { dlgMessageBox("No flags.\n"); exit(1); }		
		for (int i = 1; flags[i]; i++)
		{
			switch (flags[i])
			{
				case 'e' : regexFlag = true; break;
				case 'g' : alignToGridFlag = true; break;
				case 's' : snapFlag = true; break;
				case 'd' : distributeFlag = true; break;
				default : dlgMessageBox("No such flag.\n"); exit(3);
			}
		}	 
		firstInList++;
	}
	else break;	
}
if (argc>firstInList) mode = LIST;

board(brd)
{
	outputFileName = filedir(brd.name)+outputFileName;
	output(outputFileName, "wtD")
	{
		status("Aligning Objects...");
		brd.elements(element)
		{
			if ((mode == GROUP && ingroup(element)) || (mode == LIST && inList(element.name)))
			{
				noElements += 1;
				if (element.x < xMin) xMin = element.x;
				if (element.x > xMax) xMax = element.x;
				if (element.y < yMin) yMin = element.y;
				if (element.y > yMax) yMax = element.y;
				xAvg += element.x;
				yAvg += element.y;				
			}
		}
		if ((noElements < 2) && !dlgMessageBox("Minimum 2 objects in group/list required.\n")) exit(1);
		xAvg = xAvg / noElements;
		yAvg = yAvg / noElements;

		alignment = ((xAvg - xMin) > (yMax - yAvg)) ? VERTICAL : HORIZONTAL;
		if (alignment == HORIZONTAL)
			brd.elements(element)
		{
			if ((mode == GROUP && ingroup(element)) || (mode == LIST && inList(element.name)))
			{
				if (element.y == yMax) xAligned = (snapFlag || alignToGridFlag) ? snapToGrid(brd, element.x) : element.x;
			}
			distance = (yMax - yMin)/(noElements-1); 
		}
		else
			brd.elements(element)
		{
			if ((mode == GROUP && ingroup(element)) || (mode == LIST && inList(element.name)))
			{
				if (element.x == xMin) yAligned = (snapFlag || alignToGridFlag) ? snapToGrid(brd, element.y) : element.y;
			}
			distance = (xMax - xMin)/(noElements-1); 
		}

		int n = 0, totalDistance;
		brd.elements(element)
		{
			if ((mode == GROUP && ingroup(element)) || (mode == LIST && inList(element.name)))
			{
				if (distributeFlag)
				{
					totalDistance = ((alignment == HORIZONTAL) ? yMin : xMin) + distance * n;
					if (alignment == HORIZONTAL) printf("MOVE %s (%fmil %fmil)\n", element.name, u2mil(xAligned), u2mil(totalDistance));			
					else printf("MOVE %s (%fmil %fmil)\n", element.name, u2mil(totalDistance), u2mil(yAligned));
					n++;
				}
				else
				{
					if (alignment == HORIZONTAL) printf("MOVE %s (%fmil %fmil)\n", element.name, u2mil(xAligned), u2mil(snapFlag ? snapToGrid(brd, element.y) : element.y));			
					else printf("MOVE %s (%fmil %fmil)\n", element.name, u2mil(snapFlag ? snapToGrid(brd, element.x) : element.x), u2mil(yAligned));
				}
			}
		}
	}
}
exit("script '" + outputFileName + "'");